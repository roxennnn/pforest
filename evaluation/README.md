# **Evaluation**

### Folder Organization

The `evaluation/` folder contains all the code needed to generate the source `P4` code as well as the code to evaluate the implementation.

Inside this folder it is possible to find the code that generates the *pForest* p4 code, as well as the code to subsequently test it. 
In particular, in this folder can be found:

* `p4src/`: This folder will contain the _.p4_  files that will be generated by `generate_pforest.py`, it already contains the `p4app.json` configuration file that describes the network topology that will be created with _mininet_ and _p4utils_  in order to test the implementation. The description of the topology can be found in Section 4.1 of the report.
* `pcap/`: This folder contains the _.pcap_ files of some flows chosen randomly from the dataset.
* `controller.py`:  Python script implementing the control plane: it uses the `runtime_API` to communicate with the switch. Basically, it resets the switch’s registers and initialize the custom hash functions. It is important to run the controller right after the compilation is done.
* `generate_pforest.py`: Python script which generates the whole *pForest* system. It first generates the P4 code according to the random forest model the user wants to use for making inferences about the traffic.  Then, it builds and train the random forest model, testing its accuracy. It keeps training different models until the trained model overcomes a threshold error rate (until a pre-determined number of trained models). In case of success, the random forest model is translated in a sequence of table entries later used by the *pForest* switch.

### Evaluation Process

Following, there are a step by step explanation of how to evaluate our implementation of *pForest*. It is assumed that the starting point is this folder.

0. Before starting the evaluation process, keep in mind some tools need to be installed on your machine. Be sure the following tools are installed on your machine before continuing: 

    - `p4run`
    - python2 and  the following libraries:
       - `p4utils`
    - python3 and the following libraries:
       - `numpy`
       - `scapy`
       - `sklearn`
    - Wireshark
    - `tcpreplay`

1. First of all, the *pForest* code need to be generated. As a matter of fact, at this beginning only the topology description and the Python controller code are present. Hence, the `generate_pforest.py` program needs to be run. It takes in input 2 mandatory parameters, the number of trees we want in the random forest model and the maximum depth of each tree, and also an optional parameter, which is the certainty threshold used by the *pForest* switch. 

2. We suggest to not use too large values for the parameters. For example, to test a good number of trees could be 5 with a maximum depth of 5 each and a certainty threshold of 75%. Following this example, the command to run is:

   `$ python3 generate_pforest.py 5 5 75`

   If you did not follow the example and tried with a different combination of parameters, it could happen that no good model has been found. In this case, we suggest to try again with a smaller number of trees and/or maximum depth.

3. At this point, the whole P4 scripts and the translation of the trained random forest model have been generated. Inside the *p4src* folder can be found the following new files:

   * `pforest.p4`: main P4 code for the *pForest* system;
   * `include/headers.p4`: P4 code in which all the headers, utility structures and constants are defined;
   * `include/parser.p4`: P4 code in which the parser and the deparser are defined;
   * `s1-commands.txt`: file containing the commands to fill the match-action tables.

   Before proceeding to the next steps, it is highly suggested to open different terminals. 4 should be enough. From now on, we will suppose that those terminal are inside the current folder.

4. Inside one terminal, move into `p4src` and run `p4run`, which will call a Python script that parses the configuration file, creates a virtual network of hosts and P4 switches using `mininet`, compiles the P4 program and loads it in the switch:

   `$ cd p4src`

   `$ sudo p4run`

   After running this, you will get the `mininet` CLI prompt, meaning the virtual network has been created and the P4 program compiled.

5. Now that the virtual network is running, the controller needs to be executed. Inside another terminal, run the following command:

   `$ python controller.py --reset_regs`

   This command initialises the custom hash functions and set the registers used in the switch to 0.

6. In order to know how the switch classified the traffic, the packets being forwarded by the switch need to be captured. Wireshark will do the job. The virtual network is pretty simple. It is composed of only 3 elements: `h1`, `h2` and `s1`. The two hosts are fully connected through `s1` and all the packets arriving from a different host to the switch are forwarded to `h2`. This setting was chosen in order to simplify the whole process, using flows coming from the CICIDS dataset, thus with IP address different from  `h1`'s and `h2`'s. Therefore, we can get a terminal in `h2` and from there run Wireshark and capture all the packets forwarded to `h2`. On the same terminal or a new one, run the following commands:

   `$ mx h2`

   `$ wireshark`

   After the last command, the Wireshark window will pop up. Inside Wireshark, select the `h2-eth0` interface and press the 'Start Capturing’ button.

7. At this point, everything is set and we can start our tests. In order to send packets through `s1`, let’s get a terminal in `h1` and from there use `tcpreplay` to send all the packets from a selected flow. `tcpreplay` is used because it allows to send packets with the same inter-arrival time they were captured. Flows packets can be found inside the *pcap* folder. On a new terminal, run the following commands:

   `$ mx h1`

   `$ tcpreplay --intf1=h1-eth0 pcap/*chosen_flow.pcap*`

8. Inside Wireshark, all the traffic captured is now visible. The classification results are saved in the source MAC address field inside the Ethernet headers. In the case the flow is classified as 'BENIGN’, inside the source MAC address field of the last packets there will be written `c0:01:c0:01:c0:01`, while if the flow is classified as 'MALIGN’, there will be written `de:ad:de:ad:c0:de`. In order to check the correctness of the obtained results, keep in mind that the flows in the files starting with '172’ are MALIGN, while the ones starting with '192’ are BENIGN.

9. Some considerations about the results. 
   It can be seen that in some packets the source MAC addresses do not correspond to the ones presented for the classifications. When this happens, it means that the random forest model have not had a certainty large enough to overcome the certainty threshold. 
   It is also worthy to consider the classification behaviour in the selected malicious flows. As a matter of fact, in some of the first packets the classification is already correct. After some more packets, the classification becomes wrong. However, in the last packets the switch classified the flow as 'MALIGN’ again, thus bringing a correct classification. Having a correct classification in the last packets is expected because the random forest model has been trained using data of whole flows. However, it is still interesting to notice that the first packets were correctly classified even if we did not implemented context-dependent random forest model, as in the original *pForest* paper. We believe that this behaviour guarantees an even better performance in the case context-dependent model will be implemented in the future.